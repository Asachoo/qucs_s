<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8">
<meta name="Author" content="Michael Margraf">
<title>Qucs - Математические функции</title>
</head>



<body>
<a name="top" id="top"></a>

<center><h3>
- Qucs -<br>
Почти универсальный симулятор цепей<br>
</h3>
<h1>
Краткое описание математических функций<br><br>
</h1></center>

В уравнениях Qucs могут применяться следующие операции и функции.<br><br>

<table cellspacing=2 cellpadding=2>
<tr><td><tt>+x</tt></td><td>унарный плюс</td></tr>
<tr><td><tt>-x</tt></td><td>унарный минус</td></tr>
<tr><td><tt>x+y</tt></td><td>сложение</td></tr>
<tr><td><tt>x-y</tt></td><td>вычитание</td></tr>
<tr><td><tt>x*y</tt></td><td>умножение</td></tr>
<tr><td><tt>x/y</tt></td><td>деление</td></tr>
<tr><td><tt>x%y</tt></td><td>остаток от деления</td></tr>
<tr><td><tt>x^y</tt></td><td>возведение в степень</td></tr>
<tr><td><tt>max(x[,range])</tt></td><td>максимальное значение в векторе; если дан 
интервал <tt>range</tt>, то у <tt>x</tt> должна быть однозначная зависимость от 
данных</td></tr>
<tr><td><tt>max(x,y)</tt></td><td>возвращает большее из значений <tt>x</tt> и <tt>y</tt></td></tr>
<tr><td><tt>min(x[,range])</tt></td><td>минимальное значение в векторе; если дан 
интервал <tt>range</tt>, то у <tt>x</tt> должна быть однозначная зависимость от 
данных</td></tr>
<tr><td><tt>min(x,y)</tt></td><td>возвращает меньшее из значений <tt>x</tt> и <tt>y</tt></td></tr>
<tr><td><tt>avg(x[,range])</tt></td><td>арифметическое среднее значений в векторе; если дан интервал <tt>range</tt>, то у <tt>x</tt> должна быть однозначная 
зависимость от данных</td></tr>
<tr><td><tt>cumavg(x)</tt></td><td>накопительное среднее значений в векторе</td></tr>
<tr><td><tt>runavg(x)</tt></td><td>скользящее среднее значений в векторе</td></tr>
<tr><td><tt>stddev(x)</tt></td><td>стандартное отклонение значений в векторе</td></tr>
<tr><td><tt>variance(x)</tt></td><td>расхождение значений в векторе</td></tr>
<tr><td><tt>rms(x)</tt></td><td>среднеквадратическое значение по вектору</td></tr>
<tr><td><tt>sum(x)</tt></td><td>сумма значений в векторе</td></tr>
<tr><td><tt>prod(x)</tt></td><td>произведение значений в векторе</td></tr>
<tr><td><tt>cumsum(x)</tt></td><td>накопительная сумма значений в векторе</td></tr>
<tr><td><tt>cumprod(x)</tt></td><td>накопительное произведение значений в векторе</td></tr>
<tr><td><tt>diff(y,x)</tt></td>
<td>дифференцирует вектор y по x</td></tr>
<tr><td><tt>diff(y,x,n)</tt></td>
<td>дифференцирует вектор y по x n раз</td></tr>
<tr><td><tt>integrate(x,h)</tt></td><td>численно интегрирует вектор <tt>x</tt>, принимая постоянный размер шага <tt>h</tt></td></tr>
<tr><td><tt>real(x)</tt></td><td>вещественная часть комплексного числа</td></tr>
<tr><td><tt>imag(x)</tt></td><td>мнимая часть комплексного числа</td></tr>
<tr><td><tt>abs(x)</tt></td><td>абсолютное значение, модуль комплексного числа</td></tr>
<tr><td><tt>mag(x)</tt></td><td>то же, что и abs(x)</td></tr>
<tr><td><tt>polar(m,p)</tt></td><td>возвращает комплексное число, исходя из модуля и фазы</td></tr>
<tr><td><tt>norm(x)</tt></td><td>квадрат mag(x)</td></tr>
<tr><td><tt>conj(x)</tt></td><td>сопряженное комплексное число</td></tr>
<tr><td><tt>phase(x)</tt></td><td>фаза в градусах</td></tr>
<tr><td><tt>angle(x)</tt></td><td>фаза в радианах</td></tr>
<tr><td><tt>arg(x)</tt></td><td>то же, что и angle(x)</td></tr>
<tr><td><tt>deg2rad(x)</tt></td><td>преобразует градусы в радианы</td></tr>
<tr><td><tt>rad2deg(x)</tt></td><td>преобразует радианы в градусы</td></tr>
<tr><td><tt>unwrap(rad[,tol])</tt></td><td>разворачивает угол (в радианах), используя необязательное значение допуска (по умолчанию pi)</td></tr>
<tr><td><tt>dB(x)</tt></td><td>децибеллы напряжения</td></tr>
<tr><td><tt>dbm(x)</tt></td><td>преобразовать напряжение в мощность в дБ</td></tr>
<tr><td><tt>dbm2w(x)</tt></td><td>преобразовать мощность в dBm в мощность в ваттах</td></tr>
<tr><td><tt>w2dbm(x)</tt></td><td>преобразовать мощность в ваттах в мощность в dBm</td></tr>

<tr><td><tt>sqr(x)</tt></td><td>квадрат (x в степени два)</td></tr>
<tr><td><tt>sqrt(x)</tt></td><td>квадратный корень</td></tr>
<tr><td><tt>exp(x)</tt></td><td>экспоненциальная функция с основанием e</td></tr>
<tr><td><tt>ln(x)</tt></td><td>натуралный логарифм</td></tr>
<tr><td><tt>log10(x)</tt></td><td>десятичный логарифм</td></tr>
<tr><td><tt>log2(x)</tt></td><td>двоичный логарифм</td></tr>
<tr><td><tt>sin(x)</tt></td><td>синус</td></tr>
<tr><td><tt>cos(x)</tt></td><td>косинус</td></tr>
<tr><td><tt>tan(x)</tt></td><td>тангенс</td></tr>
<tr><td><tt>sinh(x)</tt></td><td>синус гиперболический</td></tr>
<tr><td><tt>cosh(x)</tt></td><td>косинус гиперболический</td></tr>
<tr><td><tt>tanh(x)</tt></td><td>тангенс гиперболический</td></tr>
<tr><td><tt>arcsin(x)</tt></td><td>арксинус</td></tr>
<tr><td><tt>arccos(x)</tt></td><td>арккосинус</td></tr>
<tr><td><tt>arctan(x[,y])</tt></td><td>арктангенс</td></tr>
<tr><td><tt>arccot(x)</tt></td><td>арккотангенс</td></tr>
<tr><td><tt>arsinh(x)</tt></td><td>ареасинус гиперболический</td></tr>
<tr><td><tt>arcosh(x)</tt></td><td>ареакосинус гиперболический</td></tr>
<tr><td><tt>artanh(x)</tt></td><td>ареатангенс гиперболический</td></tr>
<tr><td><tt>arcoth(x)</tt></td><td>ареакотангенс гиперболический</td></tr>
<tr><td><tt>sec(x)</tt></td><td>секанс</td></tr>
<tr><td><tt>cosec(x)</tt></td><td>косеканс</td></tr>
<tr><td><tt>cot(x)</tt></td><td>котангенс</td></tr>
<tr><td><tt>sech(x)</tt></td><td>секанс гиперболический</td></tr>
<tr><td><tt>cosech(x)</tt></td><td>косеканс гиперболический</td></tr>
<tr><td><tt>coth(x)</tt></td><td>котангенс гиперболический</td></tr>

<tr><td><tt>ztor(x[,zref])</tt></td>
<td>преобразует полное сопротивление в коэффициент отражения (по умолчанию опорное полное сопротивление равно 50 Ом)</td></tr>
<tr><td><tt>rtoz(x[,zref])</tt></td>
<td>преобразует коэффициент отражения  (по умолчанию опорное полное сопротивление равно 50 Ом) в полное сопротивление</td></tr>
<tr><td><tt>ytor(x[,zref])</tt></td>
<td>преобразует полную проводимость в коэффициент отражения (по умолчанию опорное полное сопротивление равно 50 Ом)</td></tr>
<tr><td><tt>rtoy(x[,zref])</tt></td>
<td>преобразует коэффициент отражения (по умолчанию опорное полное сопротивление равно 50 Ом) в полную проводимость</td></tr>
<tr><td><tt>rtoswr(x)</tt></td>
<td>преобразует коэффициент отражения в коэффициент стоячей волны (по напряжению) (КСВ или КСВН)</td></tr>
<tr><td><tt>stos(s,zref[,z0])</tt></td>
<td>преобразует матрицу s-параметров в матрицу s-параметров с другим(и) опорным(и) сопротивлением(ями)</td></tr>
<tr><td><tt>stoy(s[,zref])</tt></td>
<td>преобразует матрицу s-параметров в матрицу y-параметров</td></tr>
<tr><td><tt>stoz(s[,zref])</tt></td>
<td>преобразует матрицу s-параметров в матрицу z-параметров</td></tr>
<tr><td><tt>ytos(y[,z0])</tt></td>
<td>преобразует матрицу y-параметров в матрицу s-параметров</td></tr>
<tr><td><tt>ytoz(y)</tt></td>
<td>преобразует матрицу y-параметров в матрицу z-параметров</td></tr>
<tr><td><tt>ztos(z[,z0])</tt></td>
<td>преобразует матрицу z-параметров в матрицу s-параметров</td></tr>
<tr><td><tt>ztoy(z)</tt></td>
<td>преобразует матрицу z-параметров в матрицу y-параметров</td></tr>
<tr><td><tt>twoport(m,from,to)</tt></td>
<td>преобразует данную матрицу четырехполюсника из одного представления в другое, возможные значения для <tt>"from"</tt> и <tt>"to"</tt> : 'Y', 'Z', 'H', 'G',
'A', 'S' и 'T'.</td></tr>

<tr><td><tt>ceil(x)</tt></td><td>округление до ближайшего большего целого</td></tr>
<tr><td><tt>fix(x)</tt></td><td>усечение десятичных разрядов вещественного числа</td></tr>
<tr><td><tt>floor(x)</tt></td><td>округление до ближайшего меньшего целого</td></tr>
<tr><td><tt>round(x)</tt></td><td>округление до ближайшего целого</td></tr>

<tr><td><tt>sign(x)</tt></td><td>вычисление знаковой функции</td></tr>
<tr><td><tt>sinc(x)</tt></td><td>возвращает sin(x)/x и единицу при x=0</td></tr>
<tr><td><tt>step(x)</tt></td><td>шаговая функция</td></tr>
<tr><td><tt>besseli0(x)</tt></td><td>модифицированная функция Бесселя нулевого порядка</td></tr>
<tr><td><tt>besselj(n,x)</tt></td><td>функция Бесселя 1-го рода n-го порядка</td></tr>
<tr><td><tt>bessely(n,x)</tt></td><td>функция Бесселя 2-го рода n-го порядка</td></tr>
<tr><td><tt>erf(x)</tt></td><td>функция ошибки</td></tr>
<tr><td><tt>erfc(x)</tt></td><td>комплиментарная функция ошибки</td></tr>
<tr><td><tt>erfinv(x)</tt></td><td>инверсная функция ошибки</td></tr>
<tr><td><tt>erfcinv(x)</tt></td><td>инверсная комплиментарная функция ошибки</td></tr>

<tr><td><tt>det(x)</tt></td><td>детерминант x</td></tr>
<tr><td><tt>transpose(x)</tt></td><td>транспонированная матрица x (строки и столбцы меняются местами)</td></tr>
<tr><td><tt>inverse(x)</tt></td><td>инверсия матрицы x</td></tr>
<tr><td><tt>eye(n)</tt></td><td>n x n единичная матрица</td></tr>
<tr><td><tt>adjoint(x)</tt></td><td>сопряженная матрица (транспонированная и комплексно-сопряженная)</td></tr>
<tr><td><tt>Rollet(x)</tt></td><td>Фактор устойчивости Роллета для матрицы x (матрица S-параметров четырехполюсника)</td></tr>
<tr><td><tt>Mu(x)</tt></td><td>Mu фактор устойчивости для матрицы x (матрица S-параметров четырехполюсника)</td></tr>
<tr><td><tt>Mu2(x)</tt></td><td>Mu' фактор устойчивости для матрицы x (матрица S-параметров четырехполюсника)</td></tr>
<tr><td><tt>linspace(from,to,n)</tt></td><td>создает вектор с <tt>n</tt> линейно протяженными элементами между <tt>from</tt> и <tt>to</tt>, оба значения включительно</td></tr>
<tr><td><tt>logspace(from,to,n)</tt></td><td>создает вектор с <tt>n</tt> логарифмически протяженными элементами между <tt>from</tt> и <tt>to</tt>, оба значения включительно</td></tr>
<tr><td><tt>NoiseCircle(Sopt,<br>&nbsp;&nbsp;Fmin,Rn,F[,Arcs])</tt></td><td>окружности с постоянным(и) числом(ами) шума <tt>F</tt> (может быть константой или вектором), <tt>Arcs</tt> задает углы в градусах, созданные, например, с помощью <tt>linspace(0,360,100)</tt>, если <tt>Arcs</tt> явялется числом, то оно определяет количество равномерно расставленных сегментов окружности, если оно опущено, то по умолчанию используется приемлемое значение</td></tr>
<tr><td><tt>StabCircleS(S [,Arcs])</tt></td><td>окружность устойчивости в плоскости источника</td></tr>
<tr><td><tt>StabCircleL(S [,Arcs])</tt></td><td>окружность устойчивости в плоскости нагрузки</td></tr>
<tr><td><tt>GaCircle(S,Ga [,Arcs])</tt></td><td>окружность(и) с постоянным усилением располагаемой мощности <tt>Ga</tt> в плоскости источника</td></tr>
<tr><td><tt>GpCircle(S,Gp [,Arcs])</tt></td><td>окружность(и) с постоянным усилением мощности <tt>Gp</tt> в плоскости нагрузки</td></tr>
<tr><td><tt>PlotVs(data,dep)</tt></td><td>возвращает элемент данных из <tt>data</tt> (вектор или матричный вектор), зависящий от вектора <tt>dep</tt>, например, <tt>PlotVs(Gain,frequency/1e9)</tt></td></tr>
<tr><td><tt>interpolate(f,x[,n])</tt></td><td>возвращает вектор интерполированных данных вещественной функции <tt>f(x)</tt> по <tt>n</tt> равноудаленным отсчетам данных, последний параметр может быть опущен, и будет использовано приемлемое значение по умолчанию</td></tr>
<tr><td><tt>fft(x)</tt></td><td>рассчитывает быстрое преобразование Фурье (FFT) вектора <tt>x</tt></td></tr>
<tr><td><tt>ifft(x)</tt></td><td>рассчитывает обратное быстрое преобразование Фурье (IFFT) вектора <tt>x</tt></td></tr>
<tr><td><tt>dft(x)</tt></td><td>рассчитывает дискретное преобразование Фурье (DFT) вектора <tt>x</tt></td></tr>
<tr><td><tt>idft(x)</tt></td><td>рассчитывает обратное дискретное преобразование Фурье (DFT) вектора <tt>x</tt></td></tr>
<tr><td><tt>Time2Freq(v,t)</tt></td><td>рассчитывает дискретное преобразование Фурье функции <tt>v(t)</tt> с физической интерпретацией</td></tr>
<tr><td><tt>Freq2Time(V,f)</tt></td><td>рассчитывает обратное дискретное преобразование Фурье функции <tt>V(f)</tt> с физической интерпретацией</td></tr>
<tr><td><tt>kbd(x [,n])</tt></td><td>Производное окно Кайзера-Бесселя</td></tr>
<tr><td><tt>yvalue(f,xval)</tt></td><td>возвращает y-значение данного вектора 
<tt>f</tt>, ближайшее к x-значению <tt>xval</tt>; следовательно, вектор <tt>f</tt> должен иметь однозначную зависимость от данных</td></tr>
<tr><td><tt>xvalue(f,yval)</tt></td><td>возвращает x-значение, связанное с y-значением, ближайшим к <tt>yval</tt> в данном векторе <tt>f</tt>; следовательно, вектор <tt>f</tt> должен иметь однозначную зависимость от данных</td></tr>

</table>
<br>

<b>Интервалы</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>LO:HI</tt></td><td>интервал от <tt>LO</tt> до <tt>HI</tt></td></tr>
<tr><td><tt>:HI</tt></td><td>вплоть до <tt>HI</tt></td></tr>
<tr><td><tt>LO:</tt></td><td>от <tt>LO</tt></td></tr>
<tr><td><tt>:</tt></td><td>нет границ интервала</td></tr>
</table>
<br>

<b>Матрицы</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>M</tt></td><td>вся матрица M</td></tr>
<tr><td><tt>M[2,3]</tt></td><td>элемент, находящийся во 2-й строке и 3-м столбце матрицы M</td></tr>
<tr><td><tt>M[:,3]</tt></td><td>вектор, состоящий из 3-го столбца матрицы M</td></tr>
</table>
<br>

<b>Имена величин</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>S[1,1]</tt></td><td>значение S-параметра</td></tr>
<tr><td><i>nodename</i><tt>.V</tt></td><td>постоянное напряжение в узле <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.I</tt></td><td>постоянный ток через компонент <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.v</tt></td><td>переменное напряжение в узле <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.i</tt></td><td>переменный ток через компонент <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.vn</tt></td><td>шумовое напряжение переменного тока в узле <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.in</tt></td><td>шумовой переменный ток через компонент <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.Vt</tt></td><td>переходное напряжение в узле <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.It</tt></td><td>переходной ток через компонент <i>name</i></td></tr>
</table>
Примечание: Все напряжения и токи выражены пиковыми значениями.<br>
Примечание: Шумовые напряжения выражены СКЗ значениями в полосе частот в 1Гц.
<br><br>

<b>Константы</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>j</tt></td><td>мнимая единица ("квадратный корень из -1")</td></tr>
<tr><td><tt>pi</tt></td><td>4*arctan(1) = 3.14159...</td></tr>
<tr><td><tt>e</tt></td><td>e = 2.71828...</td></tr>
<tr><td><tt>kB</tt></td><td>Постоянная Больцмана = 1.38065e-23</td></tr>
</table>

<br><a href="#top">наверх</a><br>

</body>
</html>
